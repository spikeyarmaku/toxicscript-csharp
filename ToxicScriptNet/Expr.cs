namespace ToxicScriptNet;

using System.Text;

// Generated by ChatGPT
public abstract class Expr
{
    public abstract override string ToString();

    public static Expr EmptyExpr() {
        return new List(new List<Expr>());
    }

    public abstract override int GetHashCode();
    public abstract override bool Equals(object? o);

    public static Expr Parse(string input) {
        // Use a stack to keep track of nested parentheses
        var stack = new Stack<List<Expr>>();
        // This variable will be used to build the final result
        var result = new List<Expr>();
        // This variable will be used to build up each individual node as we parse the input
        var currentNode = new List<Expr>();
        // This variable will be used to keep track of the current string
        var currentString = new StringBuilder();
        // This variable will be used to track whether the previous character was an escape character
        var previousEscape = false;
        var inQuotes = false;
        var isComment = false;
        string newlineParser = "";

        foreach (char c in input) {
            if (isComment) {
                // Read characters until a newline is found
                if (Environment.NewLine.Contains(c)) {
                    newlineParser += c;
                }
                if (newlineParser == Environment.NewLine) {
                    isComment = false;
                    newlineParser = "";
                } else if (newlineParser.Length == Environment.NewLine.Length) {
                    newlineParser = newlineParser.Remove(0, 1);
                }
            }
            else if (inQuotes) {
                // Reading a string
                if (previousEscape) {
                    // An escaped character
                    previousEscape = false;
                    currentString.Append(c);
                } else {
                    // A normal character
                    if (c == '\\') {
                        previousEscape = true;
                    } else if (c == '"') {
                        // End of string
                        inQuotes = false;
                        currentString.Append(c);
                        currentNode.Add(new Symbol(currentString.ToString()));
                        currentString.Clear();
                    } else {
                        currentString.Append(c);
                    }
                }
            } else {
                // Reading a symbol
                if (c == ';') {
                    isComment = true;
                }
                else if (c == '(') {
                    if (currentString.Length > 0)
                    {
                        currentNode.Add(new Symbol(currentString.ToString()));
                        currentString.Clear();
                    }
                    stack.Push(currentNode);
                    currentNode = new List<Expr>();
                }
                else if (c == ')') {
                    // If this is a closing parenthesis, pop the last open parenthesis off the stack
                    if (stack.Count > 0)
                    {
                        if (currentString.Length > 0)
                        {
                            currentNode.Add(new Symbol(currentString.ToString()));
                            currentString.Clear();
                        }
                        var parentNode = stack.Pop();
                        parentNode.Add(new List(currentNode));
                        currentNode = parentNode;
                    }
                    else
                    {
                        // If there are no open parentheses on the stack, this is an error
                        throw new InvalidOperationException("Mismatched parentheses in input");
                    }
                }
                else if (c == '"') {
                    if (currentString.Length == 0) {
                        inQuotes = true;
                        currentString.Append(c);
                    } else {
                        throw new InvalidOperationException("Quotes inside a symbol");
                    }
                }
                else if (Char.IsWhiteSpace(c)) {
                    if (currentString.Length > 0) {
                        currentNode.Add(new Symbol(currentString.ToString()));
                        currentString.Clear();
                    }
                }
                else {
                    currentString.Append(c);
                }
            }
        }

        // If there are any open parentheses left on the stack, this is also an error
        if (stack.Count > 0) {
            throw new InvalidOperationException("Mismatched parentheses in input");
        }

        if (currentNode.Count == 1) {
            return currentNode.First();
        } else {
            return new List(currentNode);
        }
    }
}

public class Symbol : Expr
{
    public string Name { get; }

    public Symbol(string name)
    {
        Name = name;
    }

    public override string ToString()
    {
        return Name;
    }

    public override int GetHashCode() {
        return Name.GetHashCode();
    }

    public override bool Equals(object? o) {
        if (o is Symbol) {
            Symbol s = (Symbol)o;
            return s.Name == Name;
        } else {
            return false;
        }
    }
}

public class List : Expr
{
    public List<Expr> Items { get; }

    public List(List<Expr> items)
    {
        Items = items;
    }

    public override string ToString()
    {
        return "(" + string.Join(" ", Items) + ")";
    }

    // An expression is a valid combination iff it is a list, and is not empty.
    public bool IsValidCombination() {
        return Items.Count > 0;
    }

    public Expr? GetHead() {
        return Items.FirstOrDefault();
    }

    public List<Expr> GetTail() {
        return Items.Skip(1).ToList();
    }

    public override int GetHashCode() {
        int hash = 17;
        foreach (var e in Items) {
            hash ^= e.GetHashCode();
        }
        return hash;
    }

    public override bool Equals(object? o) {
        if (o is List) {
            List l = (List)o;
            return l.Items.SequenceEqual(Items);
        } else {
            return false;
        }
    }
}
// ---

